{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/tofrac.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport PINF from '@stdlib/constants-float32-pinf';\nimport NINF from '@stdlib/constants-float32-ninf';\nimport BIAS from '@stdlib/constants-float32-exponent-bias';\nimport pow from '@stdlib/math-base-special-pow';\nimport format from '@stdlib/string-format';\nimport toFloat32 from '@stdlib/number-float64-base-to-float32';\nimport toFrac from './tofrac.js';\n\n\n// MAIN //\n\n/**\n* Creates a single-precision floating-point number from an IEEE 754 literal bit representation.\n*\n* @param {BinaryString} bstr - string which is a literal bit representation\n* @throws {Error} must provide a string with a length equal to `32`\n* @returns {number} single-precision floating-point number\n*\n* @example\n* var bstr = '01000000100000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns 4.0\n*\n* @example\n* var bstr = '01000000010010010000111111011011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~3.14\n*\n* @example\n* var bstr = '11111111011011000011101000110011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~-3.14e+38\n*\n* @example\n* var bstr = '00000000000000000000000000000000';\n* var v =  fromBinaryStringf( bstr );\n* // returns 0.0\n*\n* @example\n* var bstr = '10000000000000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns -0.0\n*/\nfunction fromBinaryStringf( bstr ) {\n\tvar sign;\n\tvar frac;\n\tvar exp;\n\n\tif ( bstr.length !== 32 ) {\n\t\tthrow new Error( format( 'invalid argument. Input string must have a length equal to %u. Value: `%s`.', 32, bstr ) );\n\t}\n\t// Sign bit:\n\tsign = ( bstr[0] === '1' ) ? -1.0 : 1.0;\n\n\t// Exponent bits:\n\texp = parseInt( bstr.substring(1, 9), 2 ) - BIAS;\n\n\t// Fraction bits:\n\tfrac = toFrac( bstr.substring( 9 ) );\n\n\t// Detect `0` (all 0s) and subnormals (exponent bits are all 0, but fraction bits are not all 0s)...\n\tif ( exp === -BIAS ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? 0.0 : -0.0;\n\t\t}\n\t\texp = -(BIAS-1); // subnormals are special in that their exponent is constant\n\t}\n\t// Detect `+-inf` (exponent bits are all 1 and fraction is 0) and `NaN` (exponent bits are all 1 and fraction is not 0)...\n\telse if ( exp === BIAS+1 ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? PINF : NINF;\n\t\t}\n\t\treturn NaN;\n\t}\n\t// Normal numbers...\n\telse {\n\t\t// Account for hidden/implicit bit (2^0):\n\t\tfrac += 1.0;\n\t}\n\treturn toFloat32( sign*frac*pow(2, exp) );\n}\n\n\n// EXPORTS //\n\nexport default fromBinaryStringf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport pow from '@stdlib/math-base-special-pow';\n\n\n// MAIN //\n\n/**\n* Converts a float's fraction bit sequence to a numeric value.\n*\n* @private\n* @param {BinaryString} frac - literal bit representation of a float's fraction bit sequence\n* @returns {number} fraction value\n*\n* @example\n* var v = toFrac( '10001100010111110011000' );\n* // returns ~0.548\n*\n* @example\n* var v = toFrac( '11110101000101011111111' );\n* // returns ~0.957\n*/\nfunction toFrac( frac ) {\n\tvar sum = 0;\n\tvar i;\n\tfor ( i = 0; i < frac.length; i++ ) {\n\t\tif ( frac[ i ] === '1' ) {\n\t\t\tsum += pow( 2.0, -(i+1) );\n\t\t}\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nexport default toFrac;\n"],"names":["fromBinaryStringf","bstr","sign","frac","exp","length","Error","format","parseInt","substring","BIAS","i","sum","pow","toFrac","PINF","NINF","NaN","toFloat32"],"mappings":";;6kBAiEA,SAASA,EAAmBC,GAC3B,IAAIC,EACAC,EACAC,EAEJ,GAAqB,KAAhBH,EAAKI,OACT,MAAM,IAAIC,MAAOC,EAAQ,8EAA+E,GAAIN,IAY7G,GATAC,EAAqB,MAAZD,EAAK,IAAgB,EAAM,EAGpCG,EAAMI,SAAUP,EAAKQ,UAAU,EAAG,GAAI,GAAMC,EAG5CP,ECtCD,SAAiBA,GAChB,IACIQ,EADAC,EAAM,EAEV,IAAMD,EAAI,EAAGA,EAAIR,EAAKE,OAAQM,IACV,MAAdR,EAAMQ,KACVC,GAAOC,EAAK,IAAOF,EAAE,KAGvB,OAAOC,CACR,CD6BQE,CAAQb,EAAKQ,UAAW,IAG1BL,KAASM,EAAO,CACpB,GAAc,IAATP,EACJ,OAAkB,IAATD,EAAiB,GAAO,EAElCE,IAAQM,EAAK,EACb,KAEI,IAAKN,IAAQM,EAAK,EACtB,OAAc,IAATP,EACc,IAATD,EAAiBa,EAAOC,EAE3BC,IAKPd,GAAQ,CACR,CACD,OAAOe,EAAWhB,EAAKC,EAAKU,EAAI,EAAGT,GACpC"}