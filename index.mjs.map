{"version":3,"file":"index.mjs","sources":["../lib/tofrac.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar pow = require( '@stdlib/math-base-special-pow' );\n\n\n// MAIN //\n\n/**\n* Converts a float's fraction bit sequence to a numeric value.\n*\n* @private\n* @param {BinaryString} frac - literal bit representation of a float's fraction bit sequence\n* @returns {number} fraction value\n*\n* @example\n* var v = toFrac( '10001100010111110011000' );\n* // returns ~0.548\n*\n* @example\n* var v = toFrac( '11110101000101011111111' );\n* // returns ~0.957\n*/\nfunction toFrac( frac ) {\n\tvar sum = 0;\n\tvar i;\n\tfor ( i = 0; i < frac.length; i++ ) {\n\t\tif ( frac[ i ] === '1' ) {\n\t\t\tsum += pow( 2.0, -(i+1) );\n\t\t}\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nmodule.exports = toFrac;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar PINF = require( '@stdlib/constants-float32-pinf' );\nvar NINF = require( '@stdlib/constants-float32-ninf' );\nvar BIAS = require( '@stdlib/constants-float32-exponent-bias' );\nvar pow = require( '@stdlib/math-base-special-pow' );\nvar format = require( '@stdlib/string-format' );\nvar toFloat32 = require( '@stdlib/number-float64-base-to-float32' );\nvar toFrac = require( './tofrac.js' );\n\n\n// MAIN //\n\n/**\n* Creates a single-precision floating-point number from an IEEE 754 literal bit representation.\n*\n* @param {BinaryString} bstr - string which is a literal bit representation\n* @throws {Error} must provide a string with a length equal to `32`\n* @returns {number} single-precision floating-point number\n*\n* @example\n* var bstr = '01000000100000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns 4.0\n*\n* @example\n* var bstr = '01000000010010010000111111011011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~3.14\n*\n* @example\n* var bstr = '11111111011011000011101000110011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~-3.14e+38\n*\n* @example\n* var bstr = '00000000000000000000000000000000';\n* var v =  fromBinaryStringf( bstr );\n* // returns 0.0\n*\n* @example\n* var bstr = '10000000000000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns -0.0\n*/\nfunction fromBinaryStringf( bstr ) {\n\tvar sign;\n\tvar frac;\n\tvar exp;\n\n\tif ( bstr.length !== 32 ) {\n\t\tthrow new Error( format( 'invalid argument. Input string must have a length equal to `%u`. Value: `%s`.', 32, bstr ) );\n\t}\n\t// Sign bit:\n\tsign = ( bstr[0] === '1' ) ? -1.0 : 1.0;\n\n\t// Exponent bits:\n\texp = parseInt( bstr.substring(1, 9), 2 ) - BIAS;\n\n\t// Fraction bits:\n\tfrac = toFrac( bstr.substring( 9 ) );\n\n\t// Detect `0` (all 0s) and subnormals (exponent bits are all 0, but fraction bits are not all 0s)...\n\tif ( exp === -BIAS ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? 0.0 : -0.0;\n\t\t}\n\t\texp = -(BIAS-1); // subnormals are special in that their exponent is constant\n\t}\n\t// Detect `+-inf` (exponent bits are all 1 and fraction is 0) and `NaN` (exponent bits are all 1 and fraction is not 0)...\n\telse if ( exp === BIAS+1 ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? PINF : NINF;\n\t\t}\n\t\treturn NaN;\n\t}\n\t// Normal numbers...\n\telse {\n\t\t// Account for hidden/implicit bit (2^0):\n\t\tfrac += 1.0;\n\t}\n\treturn toFloat32( sign*frac*pow(2, exp) );\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromBinaryStringf;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Create a single-precision floating-point number from an IEEE 754 literal bit representation.\n*\n* @module @stdlib/number-float32-base-from-binary-string\n*\n* @example\n* var fromBinaryStringf = require( '@stdlib/number-float32-base-from-binary-string' );\n*\n* var bstr = '01000000100000000000000000000000';\n* var val = fromBinaryStringf( bstr );\n* // returns 4.0\n*\n* bstr = '01000000010010010000111111011011';\n* val = fromBinaryStringf( bstr );\n* // returns ~3.14\n*\n* bstr = '11111111011011000011101000110011';\n* val = fromBinaryStringf( bstr );\n* // returns ~-3.14e+38\n*/\n\n// MODULES //\n\nvar fromBinaryStringf = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = fromBinaryStringf;\n"],"names":["pow","require$$0","PINF","NINF","require$$1","BIAS","require$$2","require$$3","format","require$$4","toFloat32","require$$5","toFrac","frac","i","sum","length","lib","bstr","sign","exp","Error","parseInt","substring","NaN"],"mappings":";;miBAsBA,IAAIA,EAAMC,EAkCV,IClCIC,EAAOD,EACPE,EAAOC,EACPC,EAAOC,EACPN,EAAMO,EACNC,EAASC,EACTC,EAAYC,EACZC,EDcJ,SAAiBC,GAChB,IACIC,EADAC,EAAM,EAEV,IAAMD,EAAI,EAAGA,EAAID,EAAKG,OAAQF,IACV,MAAdD,EAAMC,KACVC,GAAOf,EAAK,IAAOc,EAAE,KAGvB,OAAOC,GCyDR,IC3DAE,EDiBA,SAA4BC,GAC3B,IAAIC,EACAN,EACAO,EAEJ,GAAqB,KAAhBF,EAAKF,OACT,MAAM,IAAIK,MAAOb,EAAQ,gFAAiF,GAAIU,IAY/G,GATAC,EAAqB,MAAZD,EAAK,IAAgB,EAAM,EAGpCE,EAAME,SAAUJ,EAAKK,UAAU,EAAG,GAAI,GAAMlB,EAG5CQ,EAAOD,EAAQM,EAAKK,UAAW,IAG1BH,KAASf,EAAO,CACpB,GAAc,IAATQ,EACJ,OAAkB,IAATM,EAAiB,GAAO,EAElCC,IAAQf,EAAK,OAGT,CAAA,GAAKe,IAAQf,EAAK,EACtB,OAAc,IAATQ,EACc,IAATM,EAAiBjB,EAAOC,EAE3BqB,IAKPX,GAAQ,EAET,OAAOH,EAAWS,EAAKN,EAAKb,EAAI,EAAGoB"}