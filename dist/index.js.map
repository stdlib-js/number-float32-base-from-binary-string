{
  "version": 3,
  "sources": ["../lib/tofrac.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar pow = require( '@stdlib/math-base-special-pow' );\n\n\n// MAIN //\n\n/**\n* Converts a float's fraction bit sequence to a numeric value.\n*\n* @private\n* @param {BinaryString} frac - literal bit representation of a float's fraction bit sequence\n* @returns {number} fraction value\n*\n* @example\n* var v = toFrac( '10001100010111110011000' );\n* // returns ~0.548\n*\n* @example\n* var v = toFrac( '11110101000101011111111' );\n* // returns ~0.957\n*/\nfunction toFrac( frac ) {\n\tvar sum = 0;\n\tvar i;\n\tfor ( i = 0; i < frac.length; i++ ) {\n\t\tif ( frac[ i ] === '1' ) {\n\t\t\tsum += pow( 2.0, -(i+1) );\n\t\t}\n\t}\n\treturn sum;\n}\n\n\n// EXPORTS //\n\nmodule.exports = toFrac;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar PINF = require( '@stdlib/constants-float32-pinf' );\nvar NINF = require( '@stdlib/constants-float32-ninf' );\nvar BIAS = require( '@stdlib/constants-float32-exponent-bias' );\nvar pow = require( '@stdlib/math-base-special-pow' );\nvar format = require( '@stdlib/string-format' );\nvar toFloat32 = require( '@stdlib/number-float64-base-to-float32' );\nvar toFrac = require( './tofrac.js' );\n\n\n// MAIN //\n\n/**\n* Creates a single-precision floating-point number from an IEEE 754 literal bit representation.\n*\n* @param {BinaryString} bstr - string which is a literal bit representation\n* @throws {Error} must provide a string with a length equal to `32`\n* @returns {number} single-precision floating-point number\n*\n* @example\n* var bstr = '01000000100000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns 4.0\n*\n* @example\n* var bstr = '01000000010010010000111111011011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~3.14\n*\n* @example\n* var bstr = '11111111011011000011101000110011';\n* var v = fromBinaryStringf( bstr );\n* // returns ~-3.14e+38\n*\n* @example\n* var bstr = '00000000000000000000000000000000';\n* var v =  fromBinaryStringf( bstr );\n* // returns 0.0\n*\n* @example\n* var bstr = '10000000000000000000000000000000';\n* var v = fromBinaryStringf( bstr );\n* // returns -0.0\n*/\nfunction fromBinaryStringf( bstr ) {\n\tvar sign;\n\tvar frac;\n\tvar exp;\n\n\tif ( bstr.length !== 32 ) {\n\t\tthrow new Error( format( 'invalid argument. Input string must have a length equal to %u. Value: `%s`.', 32, bstr ) );\n\t}\n\t// Sign bit:\n\tsign = ( bstr[0] === '1' ) ? -1.0 : 1.0;\n\n\t// Exponent bits:\n\texp = parseInt( bstr.substring(1, 9), 2 ) - BIAS;\n\n\t// Fraction bits:\n\tfrac = toFrac( bstr.substring( 9 ) );\n\n\t// Detect `0` (all 0s) and subnormals (exponent bits are all 0, but fraction bits are not all 0s)...\n\tif ( exp === -BIAS ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? 0.0 : -0.0;\n\t\t}\n\t\texp = -(BIAS-1); // subnormals are special in that their exponent is constant\n\t}\n\t// Detect `+-inf` (exponent bits are all 1 and fraction is 0) and `NaN` (exponent bits are all 1 and fraction is not 0)...\n\telse if ( exp === BIAS+1 ) {\n\t\tif ( frac === 0.0 ) {\n\t\t\treturn ( sign === 1.0 ) ? PINF : NINF;\n\t\t}\n\t\treturn NaN;\n\t}\n\t// Normal numbers...\n\telse {\n\t\t// Account for hidden/implicit bit (2^0):\n\t\tfrac += 1.0;\n\t}\n\treturn toFloat32( sign*frac*pow(2, exp) );\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromBinaryStringf;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Create a single-precision floating-point number from an IEEE 754 literal bit representation.\n*\n* @module @stdlib/number-float32-base-from-binary-string\n*\n* @example\n* var fromBinaryStringf = require( '@stdlib/number-float32-base-from-binary-string' );\n*\n* var bstr = '01000000100000000000000000000000';\n* var val = fromBinaryStringf( bstr );\n* // returns 4.0\n*\n* bstr = '01000000010010010000111111011011';\n* val = fromBinaryStringf( bstr );\n* // returns ~3.14\n*\n* bstr = '11111111011011000011101000110011';\n* val = fromBinaryStringf( bstr );\n* // returns ~-3.14e+38\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAM,QAAS,+BAAgC,EAoBnD,SAASC,EAAQC,EAAO,CACvB,IAAIC,EAAM,EACNC,EACJ,IAAMA,EAAI,EAAGA,EAAIF,EAAK,OAAQE,IACxBF,EAAME,CAAE,IAAM,MAClBD,GAAOH,EAAK,EAAK,EAAEI,EAAE,EAAG,GAG1B,OAAOD,CACR,CAKAJ,EAAO,QAAUE,ICxDjB,IAAAI,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,yCAA0C,EAC1DC,EAAM,QAAS,+BAAgC,EAC/CC,EAAS,QAAS,uBAAwB,EAC1CC,EAAY,QAAS,wCAAyC,EAC9DC,EAAS,IAqCb,SAASC,EAAmBC,EAAO,CAClC,IAAIC,EACAC,EACAC,EAEJ,GAAKH,EAAK,SAAW,GACpB,MAAM,IAAI,MAAOJ,EAAQ,8EAA+E,GAAII,CAAK,CAAE,EAYpH,GATAC,EAASD,EAAK,CAAC,IAAM,IAAQ,GAAO,EAGpCG,EAAM,SAAUH,EAAK,UAAU,EAAG,CAAC,EAAG,CAAE,EAAIN,EAG5CQ,EAAOJ,EAAQE,EAAK,UAAW,CAAE,CAAE,EAG9BG,IAAQ,CAACT,EAAO,CACpB,GAAKQ,IAAS,EACb,OAASD,IAAS,EAAQ,EAAM,GAEjCE,EAAM,EAAET,EAAK,EACd,KAEK,IAAKS,IAAQT,EAAK,EACtB,OAAKQ,IAAS,EACJD,IAAS,EAAQT,EAAOC,EAE3B,IAKPS,GAAQ,EAET,OAAOL,EAAWI,EAAKC,EAAKP,EAAI,EAAGQ,CAAG,CAAE,CACzC,CAKAZ,EAAO,QAAUQ,IChEjB,IAAIK,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_tofrac", "__commonJSMin", "exports", "module", "pow", "toFrac", "frac", "sum", "i", "require_main", "__commonJSMin", "exports", "module", "PINF", "NINF", "BIAS", "pow", "format", "toFloat32", "toFrac", "fromBinaryStringf", "bstr", "sign", "frac", "exp", "main"]
}
